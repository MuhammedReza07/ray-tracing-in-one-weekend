# Ray Tracing in One Weekend

A Rust implementation of a ray tracer implementing *most of* the features of the ray tracer described in [Peter Shirley's *Ray Tracing in One Weekend* book series](https://raytracing.github.io/), which took me *significantly* more than nine days (a weekend and the following week) to write.

![Ray Tracing in One Weekend: Final render of book 1](/assets/28.jpeg)

Various differences between my implementation and the reference implementation provided in *Ray Tracing in One Weekend* are listed below.
- As stated in the introduction, I have chosen not to implement certain features described in the books. These features are listed below.
    - (Book 2, chapter 2) Motion blur.
- My implementation of dielectrics allows setting an absorbance value, which sets the colour of the dielectric with attenuation determined by Beer's law.
- Like Shirley, I chose to write my own functions for vector operations for vectors in 3-dimensional Euclidean space. In order to make my renders run faster on my surprisingly limited hardware (my laptop barely functions when I keep a browser window and my code editor open simultaneously), I decided to implement the vector operations using Intel's SSE SIMD ISA extensions. A consequence of this is the fact that I use `float`s (`f32`) where Shirley uses `double`s (`f64`), another consequence is that I have replaced `Vector3` with ` Vector4` (i.e. 3-vectors with 4-vectors) in the code since SSE operates on four 32-bit floating point numbers at a time.
    - All functions are designed in a manner such that they should be possible to run even on hardware without the SSE ISA extensions.
    - All functions that use dot products (or the *Euclidean inner product* if you are more mathematically inclined) are written to leverage the dot product intrinsic on platforms that support SSE >=4.1, i.e. `_mm_dp_ps`, and have a fallback version that only uses SSE intrinsics in case the platform only supports SSE <4.1.
- Random number generation is done using the `rand` crate. Instead of selecting a specific RNG for all random number generation purposes, I have chosen to use generics in order to allow the user to select their preferred random number generator when rendering the scenes.
    - Note that each thread has its own reseeded clone of the chosen RNG, and that the reseeding process is not controlled by the user due to the way in which the new seeds are generated (using `SeedableRng::from_os_rng()`).
    - The seed used for generating the scenes is fixed to ensure consistent image appearance when random numbers are used to determine scene layout. The PRNG and seed used for all renders are `rand_pcg::Pcg64Mcg`, and the 128-bit unsigned integer `0x323030372d30382d33314d696b753339` respectively.
- The scene rendering is somewhat parallelised using multithreading, with multiple rendering threads that render disjoint sets of scan lines and a single "writer" thread that writes the scan lines to an image. Notably, the coordination between the threads is done by message passing instead of mutexes (only a single message from each renderer to the writer is required per render so this is more efficient).

# Timeline
![Graphics "Hello World!"](/assets/1.jpeg)<br>
1\. Graphics "Hello World!".

![Background gradient](/assets/2.jpeg)<br>
2\. Background gradient from blue to white.

![Two spheres](/assets/3.jpeg)<br>
3\. Sphere intersections (incorrect).

![Shading with normals (incorrect)](/assets/4.jpeg)<br>
4\. Sphere normal computations (also incorrect because the intersection code is incorrect).

![Shading with normals (+z)](/assets/5.jpeg)
![Shading with normals (-z)](/assets/6.jpeg)<br>
5\. Sphere intersections corrected, the centre (green -> red) sphere is now shaded correctly. The image with the blue -> purple/pink centre sphere was generated by placing the spheres in the $-z$ direction.

![No anti-aliasing](/assets/7.jpeg)
![Anti-aliasing](/assets/8.jpeg)<br>
6\. Anti-aliasing.

![Grey diffuse spheres with shadow acne](/assets/9.jpeg)
![White diffuse spheres with shadow acne](/assets/10.jpeg)<br>
7\. Non-Lambertian diffuse spheres with shadow acne.

![Grey diffuse spheres without shadow acne](/assets/11.jpeg)<br>
8\. Non-Lambertian diffuse spheres without shadow acne.

![Lambertian grey diffuse spheres](/assets/12.jpeg)<br>
9\. Lambertian diffuse spheres.

![Three spheres on ground, two metallic and one Lambertian](/assets/13.jpeg)<br>
10\. Specular reflection.

![Gamma correction](/assets/14.jpeg)<br>
11\. Gamma correction (decoding gamma 2.2).

![Three spheres on ground, two metallic and one Lambertian](/assets/15.jpeg)
![Fuzzy specular reflection](/assets/16.jpeg)<br>
12\. Fuzzy specular reflection.

![Transparent (glass-like) dielectric](/assets/17.jpeg)
![Red dielectric 1](/assets/18.jpeg)<br>
![Red dielectric 2](/assets/19.jpeg)
![Red dielectric 3](/assets/20.jpeg)<br>
![Air bubble under water 1](/assets/21.jpeg)
![Air bubble under water 2](/assets/22.jpeg)<br>
13\. Dielectrics that always refract with total internal reflection and attenuation in accordance with Beer's law.

![Hollow glass sphere](/assets/23.jpeg)<br>
14\. Dielectric reflectivity computed using Schlick's approximation.

![Hollow glass sphere](/assets/24.jpeg)<br>
![Hollow glass sphere, zoomed in 1](/assets/25.jpeg)<br>
![Hollow glass sphere, zoomed in 2](/assets/26.jpeg)<br>
15\. Adaptable camera orientation and FOV.

![Depth of field](/assets/27.jpeg)<br>
16\. Depth of field.

![Final render of book 1 (1)](/assets/28.jpeg)<br>
![Final render of book 1 (2)](/assets/29.jpeg)<br>
17\. Two variants of the final render of book 1.

![Broken render 1](/assets/30.jpeg)<br>
![Broken render 2](/assets/31.jpeg)<br>
![Broken render 3](/assets/32.jpeg)<br>
18\. Multithreading and more robust image I/O.

![Final render of book 1 (3)](/assets/33.jpeg)<br>
19\. Switch from `Vector3` to SIMD `Vector4` (differences in scene layout probably due to use of `f32` in RNG).